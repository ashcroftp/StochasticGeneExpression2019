#' dataAnalysisFunctions.R
#' Authors: Lei Sun & Peter Ashcroft, ETH Zurich

#' Dependencies:
library(reshape2)

#' Function list:
#' - analysePopSize()
#' - withinCellDF()


#' Take the family tree data frame,
#' and return a dataframe of population sizes over time.
#' @param tree (dataframe): contains birth and death times of cells, as well as pedigree.
#' This is generated by \code{simulateCells()}
#' @return (dataframe): Size of population over time, broken up into cell groups
#' @examples analysePopSize(tree)
analysePopSize <- function(tree) {
    # Identify which cell types are present, as well as time range.
    tree$mutation <- factor(tree$mutation)
    cell.types <- levels(tree$mutation)
    
    t.min <- min(tree$first.time)
    t.max <- max(tree$last.time)
    
    delta.names <- paste("delta", cell.types, sep = ".")
    names(delta.names) <- cell.types
    
    # Order tree by time when things happen
    tree <- tree[order(tree$last.time),]
    # Does the cell reproduce (live until the end of its generation)?
    tree$reproduce <- (abs((tree$last.time - tree$first.time)/tree$generation.time - 1) < 10e-10)
    
    ## Dataframe of population changes
    # First count how many initial cells of each type there are
    change.df <- data.frame(
        time = t.min,
        lapply(cell.types, function(cell.type) {
            sum(tree$mutation == cell.type & tree$first.time == t.min)
        })
    )
    # Assign proper names to columns
    names(change.df) <- c("time", delta.names)
    
    # Add population changes due to each event
    temp.df <- lapply(seq_len(nrow(tree)), function(i) {
        vec <- c(time = tree[i,"last.time"], rep.int(0, length(cell.types)))
        names(vec) <- c("time", delta.names)
        # Check to see if cell dies
        if (tree[i,"alive"] == 0) {
            vec[delta.names[tree[i, "mutation"]]] <- -1
            return(vec)
        }
        # Check to see if reproduces
        else if ( tree[i,"reproduce"]) {
            vec[delta.names[tree[i, "mutation"]]] <- +1
            return(vec)
        }
        # Otherwise, nothing happens
        else return(NULL)
    })
    # Combine into single df
    temp.df <- as.data.frame(do.call(rbind, temp.df))
    
    # Combine to single DF
    change.df <- rbind(change.df, temp.df)
    # Sum up population changes to get number
    pop.size <- data.frame(
        time = change.df$time,
        lapply(cell.types, function(cell.type) {
            cumsum(change.df[, delta.names[[cell.type]]])
        })
    )
    names(pop.size) <- c("time", cell.types)
    
    # Add total population column by summing over rows
    pop.size$Total <- apply(as.matrix(pop.size[, names(pop.size) != "time"]), MARGIN = 1, FUN = sum)
    # Add a final row if the simulation stops abruptly
    n <- nrow(pop.size)
    if (pop.size[n,"time"] != t.max) {
        pop.size[n + 1, ] <- pop.size[n, ]
        pop.size[n + 1, "time"] <- t.max
    }
    return(pop.size)
}

#' Take the model output and add the cell volume (if necessary), as well as concentrations for each non-DNA variable, and the fraction of bound targets
#' @param generation (numeric): Unique identifier of the each cell (the generation label)
#' @param data (dataframe): Timeseries output from the SSA or ODE model solution for this cell
#' @param params (list): List of model parameters for this cell
#' @param add.volume (logical): Do we need to add a volume column before computing concentrations
#' @value A dataframe of containing this cell's timeseries, with concentrations and fraction bound targets added
withinCellDF <- function(generation, data, params, add.volume = TRUE) {
    #' Add the unique label to identify cells
    data$generation <- generation
    #' Add the cell volume column (if needed)
    if (add.volume) data$volume <- with(params, pi * (cell.diameter / 2) ^ 2 * cell.initialLength * 2 ^ ((data$time - data$time[1]) / generationTime))
    #' Add concentrations
    for (var in names(data)[!names(data) %in% c("time", "efflux.DNA", "alive", "generation", "volume")]) {
        data[, paste(var, "concentration", sep = ".")] <- data[, var]/data[, "volume"]
    }
    rm(var)
    #' Add fraction of bound targets
    data$fraction.bound.targets <- data$target.dimer / (data$target.protein + data$target.dimer)
    #'
    return(data)
}
