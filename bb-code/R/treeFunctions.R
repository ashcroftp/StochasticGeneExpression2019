#' treeFunctions.R
#' Authors: Lei Sun & Peter Ashcroft, ETH Zurich

#' Dependencies:
library(reshape2)
library(ape)
suppressMessages(library(igraph))
suppressMessages(library(ggtree))

#' Function list:
#' - analyseTreeStructure()
#' - plotFamilyTree()
#' - plotPhyloTree()

#' Turn our family tree into an actual tree structure using APE
#' 
#' \code{analyse.treeStructure}
#' 
#' @param family.tree (dataframe): contains birth and death times of cells, as well as pedigree.
#' This is generated by \code{simulate.cells()}
#' @return list (class="phylo): A tree-structured list containing edge information, as well as genotype groupings
#' @examples analyse.treeStructure(family.tree)
analyseTreeStructure <- function(family.tree){
    ## Modify family tree to account for hidden nodes
    # Identify our initial cell, and which genotypes we are looking at
    initial.cells <- family.tree[family.tree$parent.id == "0", "cell.id"]
    clades <- unique(family.tree[family.tree$cell.id %in% initial.cells, "mutation"])
    # Create hidden nodes to group our clades (need if we have more than one initial cell of a genotype)
    hidden.nodes <- max(as.numeric(family.tree$cell.id)) + c(1:length(clades))
    names(hidden.nodes) <- clades
    # Create more hidden nodes for plotting reasons
    hidden.hidden.nodes <- max(hidden.nodes) + c(1:length(clades))
    names(hidden.hidden.nodes) <- clades
    # Reorder connections, so that first cells connect to hidden node (instead of 0)
    for (id in initial.cells) family.tree[family.tree$cell.id == id, "parent.id"] <- hidden.nodes[[family.tree[family.tree$cell.id==id, "mutation"]]]
    # Now let the hidden node connect to the "0", with a zero-length connection
    for (clade in clades) {
        new.row <- data.frame(
            cell.id = hidden.nodes[[clade]],
            parent.id = hidden.hidden.nodes[[clade]],
            first.time = 0,
            last.time = 0,
            alive = 1,
            mutation = clade,
            generation.time = 0,
            simulated = 0)
        
        family.tree <- rbind(family.tree, new.row)
        
        new.row <- data.frame(
            cell.id = hidden.hidden.nodes[[clade]],
            parent.id = "0",
            first.time = 0,
            last.time = 0,
            alive = 1,
            mutation = NA,
            generation.time = 0,
            simulated = 0)
        
        family.tree <- rbind(family.tree, new.row)
    }
    # Reorder family.tree
    #family.tree <- rbind(family.tree[c((nrow(family.tree)-length(clades)+1):nrow(family.tree)),], family.tree[c(1:(nrow(family.tree)-length(clades))), ])
    #row.names(family.tree) <- c(1:nrow(family.tree))
    
    ## Identify which cells are "tips" in our tree, and which are "nodes"
    tips <- as.numeric(family.tree[!family.tree$cell.id %in% family.tree$parent.id, "cell.id"])
    nodes <- as.numeric(c(0, family.tree[family.tree$cell.id %in% family.tree$parent.id, "cell.id"]) )
    
    # Cells must be ordered as tips first, and then nodes.
    # Here we create a vector where the cell.id-th position returns the ordered index from 1 to N+1
    index  <- c()
    count <- 1
    for (i in tips) {
        index[i + 1] <- count
        count <- count + 1
    }
    for (i in nodes) {
        index[i + 1] <- count
        count <- count + 1
    }
    # Access function -- because we need a zero index :/
    get.index <- function(cell.id) index[as.numeric(cell.id) + 1]
    
    # create a matrix of edges from parent to child
    edges <- matrix(
        c(get.index(family.tree[, "parent.id"]), get.index(family.tree[, "cell.id"]) ),
        ncol = 2
    )
    
    # Define edge lengths (i.e. lifetime of cell)
    edge.length <- family.tree[, "last.time"] - family.tree[, "first.time"]
    
    # Create tree list, and assign it the "phylo" class
    tree <- list(
        edge = edges,
        tip.label = as.character(tips),
        edge.length = edge.length,
        Nnode = length(nodes),
        node.label = as.character(nodes)
    )
    class(tree) <- "phylo"
    
    # Now separate into clades based on mutation type
    #base <- initial.cells
    base <- hidden.nodes
    clade.origin <- get.index(base)
    clade.class <- family.tree[family.tree$cell.id %in% base, "mutation"]
    tree <- groupClade(tree, node = clade.origin, group_name = "mutation")
    # Rewrite numeric clades using the mutant classes
    levels(attributes(tree)$mutation) <- c(NA, clade.class)
    
    # Separate into groups based on tip genotype
    # tip.list <- lapply(clades, function(clade) family.tree[family.tree$mutation==clade & family.tree$cell.id %in% tips,"cell.id"])
    # tree <- groupOTU(tree, focus=tip.list, group_name="mutation")
    # ggtree(tree, aes(color=mutation)) + geom_tiplab()
    # # Rewrite numeric clades using the mutant classes
    # levels(attributes(tree)$mutation) <- c(NA, clades)
    
    return(tree)
}

#' Plot the branching process as a network (using iGraph)
#' EDIT FOR NEW MUTANT CLASSES
#' \code{plotFamilyTree}
#' 
#' @param family.tree (dataframe): contains birth and death times of cells, as well as pedigree.
#' This is generated by \code{simulateCells()}
#' @return A graphical object showing the branching process
#' @examples plotFamilyTree(family.tree)
plotFamilyTree <- function(family.tree) {
    # Create dataframe of edges
    edges <- data.frame(from = family.tree$parent.id, to = family.tree$cell.id)
    # edges <- data.frame(from=family.tree$parent.id[family.tree$parent.id!=0], to=family.tree$cell.id[family.tree$parent.id!=0])
    # Dataframe of node types
    type.df <- data.frame(node = c(0, family.tree$cell.id),
                          type = c("WT", as.character(family.tree$mutation))
    )
    # Create network
    net <- graph_from_data_frame(edges, vertices = type.df)
    # Add colour to nodes
    V(net)$color <- ifelse(V(net)$type == "KO",
                           "darkmagenta",
                           ifelse(V(net)$type == "Reg",
                                  "orange",
                                  ifelse(V(net)$type == "Struct",
                                         "green",
                                         "lightblue"
                                  )
                           )
    )
    # Plot as a tree (Reingold--Tilford layout)
    plot <- plot.igraph(net, layout = layout.reingold.tilford)
    
    return(plot)
}


#' Plot the branching process as a phylogenetic tree (using ggtree)
#' EDIT FOR NEW MUTANT CLASSES
#' \code{plotPhyloTree}
#' 
#' @param tree (list (class="phylo)): A tree structure, as generated by \code{analyseTreeStructure()}
#' @return A graphical object showing the tree structure
#' @examples plotPhyloTree(tree)
plotPhyloTree <- function(tree){
    # Determine plot colours using the clades
    clades <- levels(attributes(tree)$mutation)
    clade.colours <- ifelse(clades == "KO", "darkmagenta", ifelse(clades == "WT", "lightblue", ifelse(clades == "Reg", "orange", ifelse(clades == "Struct", "green", rgb(0,0,0,alpha = 0)) ) ) )
    # Plot the basic tree
    plot <- ggtree(tree, aes(color = mutation)) + scale_color_manual(breaks = clades, values = clade.colours)
    # Add a scale bar (time axis)
    plot <- plot + theme_tree2()
    # Add legend
    #plot <- plot + theme(legend.position = "right")
    # Add tip and/or node labels
    #plot <- plot + geom_text2(aes(subset=!isTip, label=node), hjust=-.3) + geom_tiplab()
    # Add clade labels (EDIT)
    #plot <- plot + geom_cladelabel(node=50, label="test label", align=T, color='red')
    return(plot)
}
