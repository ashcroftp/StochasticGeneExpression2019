#' dataAnalysisFunctions.R
#' Authors: Lei Sun & Peter Ashcroft, ETH Zurich

#' Dependencies:
if (basename(getwd()) == "bb-code") {
    source("R/basicFunctions.R")
    source("Simulate/filenames.R")
} else {
    source("../R/basicFunctions.R")
    source("../Simulate/filenames.R")
}
library(reshape2)

#' Function list:
#' - analysePopSize()
#' - withinCellDF()
#' - computeSurvival()
#' - computeGrowth()
#' - fitSpline()
#' - computeICX()


#' Take the family tree data frame,
#' and return a dataframe of population sizes over time.
#' @param tree (dataframe): contains birth and death times of cells, as well as pedigree.
#' This is generated by \code{simulateCells()}
#' @return (dataframe): Size of population over time, broken up into cell groups
#' @examples analysePopSize(tree)
analysePopSize <- function(tree) {
    # Identify which cell types are present, as well as time range.
    tree$mutation <- factor(tree$mutation)
    cell.types <- levels(tree$mutation)
    
    t.min <- min(tree$first.time)
    t.max <- max(tree$last.time)
    
    delta.names <- paste("delta", cell.types, sep = ".")
    names(delta.names) <- cell.types
    
    # Order tree by time when things happen
    tree <- tree[order(tree$last.time),]
    # Does the cell reproduce (live until the end of its generation)?
    tree$reproduce <- (abs((tree$last.time - tree$first.time)/tree$generation.time - 1) < 10e-10)
    
    ## Dataframe of population changes
    # First count how many initial cells of each type there are
    change.df <- data.frame(
        time = t.min,
        lapply(cell.types, function(cell.type) {
            sum(tree$mutation == cell.type & tree$first.time == t.min)
        })
    )
    # Assign proper names to columns
    names(change.df) <- c("time", delta.names)
    
    # Add population changes due to each event
    temp.df <- lapply(seq_len(nrow(tree)), function(i) {
        vec <- c(time = tree[i,"last.time"], rep.int(0, length(cell.types)))
        names(vec) <- c("time", delta.names)
        # Check to see if cell dies
        if (tree[i,"alive"] == 0) {
            vec[delta.names[tree[i, "mutation"]]] <- -1
            return(vec)
        }
        # Check to see if reproduces
        else if ( tree[i,"reproduce"]) {
            vec[delta.names[tree[i, "mutation"]]] <- +1
            return(vec)
        }
        # Otherwise, nothing happens
        else return(NULL)
    })
    # Combine into single df
    temp.df <- as.data.frame(do.call(rbind, temp.df))
    
    # Combine to single DF
    change.df <- rbind(change.df, temp.df)
    # Sum up population changes to get number
    pop.size <- data.frame(
        time = change.df$time,
        lapply(cell.types, function(cell.type) {
            cumsum(change.df[, delta.names[[cell.type]]])
        })
    )
    names(pop.size) <- c("time", cell.types)
    
    # Add total population column by summing over rows
    pop.size$Total <- apply(as.matrix(pop.size[, names(pop.size) != "time"]), MARGIN = 1, FUN = sum)
    # Add a final row if the simulation stops abruptly
    n <- nrow(pop.size)
    if (pop.size[n,"time"] != t.max) {
        pop.size[n + 1, ] <- pop.size[n, ]
        pop.size[n + 1, "time"] <- t.max
    }
    return(pop.size)
}

#' Take the model output and add the cell volume (if necessary), as well as concentrations for each non-DNA variable, and the fraction of bound targets
#' @param generation (numeric): Unique identifier of the each cell (the generation label)
#' @param data (dataframe): Timeseries output from the SSA or ODE model solution for this cell
#' @param params (list): List of model parameters for this cell
#' @param add.volume (logical): Do we need to add a volume column before computing concentrations
#' @value A dataframe of containing this cell's timeseries, with concentrations and fraction bound targets added
withinCellDF <- function(generation, data, params, add.volume = TRUE) {
    #' Add the unique label to identify cells
    data$generation <- generation
    #' Add the cell volume column (if needed)
    if (add.volume) data$volume <- with(params, pi * (cell.diameter / 2) ^ 2 * cell.initialLength * 2 ^ ((data$time - data$time[1]) / generationTime))
    #' Add concentrations
    for (var in names(data)[!names(data) %in% c("time", "efflux.DNA", "alive", "generation", "volume")]) {
        data[, paste(var, "concentration", sep = ".")] <- data[, var]/data[, "volume"]
    }
    rm(var)
    #' Add fraction of bound targets
    data$fraction.bound.targets <- data$target.dimer / (data$target.protein + data$target.dimer)
    #'
    return(data)
}

#' Compute the lineage survival probability
computeSurvival <- function(data.directory, file.id) {
    #' Load the data
    data <- read.csv(output.file(data.directory, file.id))
    #data$sim.label <- factor(data$sim.label, levels = sort(unique(data$sim.label)))
    data$param.index <- factor(data$param.index, levels = sort(unique(data$param.index)))
    
    #' Compute the survival probability and mean extinction time for each parameter set
    survival <- by(data, list(data$param.index), function(df) {
        tmp <- df[1, ]
        tmp$survive <- mean(df$survive)
        tmp$extinction.time <- mean(df[df$survive == 0, "exit.time"])
        tmp$extinction.time.sd <- sd(df[df$survive == 0, "exit.time"])
        tmp$num.reps <- nrow(df)
        return(tmp[, names(tmp)[!names(tmp) %in% c("sim.label", "num.cells", "exit.time")]])
    })
    survival <- do.call(rbind, survival)
    return(survival)
}


#' Compute population growth rates
computeGrowth <- function(data.directory, file.id, final.times = 60) {
    #' Load the data
    data <- read.csv(output.file(data.directory, file.id))
    #data$sim.label <- factor(data$sim.label, levels = sort(unique(data$sim.label)))
    data$param.index <- factor(data$param.index, levels = sort(unique(data$param.index)))
    
    
    
    #' Sum over the simulations
    summed.data <- by(data, list(data$sample.time, data$param.index), function(df) {
        tmp <- df[1, ]
        tmp$num.cells <- sum(df$num.cells)
        return(tmp[, names(tmp)[names(tmp) != "sim.label"]])
    })
    summed.data <- do.call(rbind, summed.data)
    
    #' Compute growth rates
    growth.rates <- by(summed.data, list(summed.data$param.index), function(df) {
        DFapply(final.times, function(t.end) {
            dff <- df[df$num.cells > 0 & df$sample.time <= t.end, ]
            ic <- dff[dff$sample.time == 0, "num.cells"]
            
            fit.df <- data.frame(sample.time = dff$sample.time, fit.var = log10(dff$num.cells) - log10(ic))
            rate <- lm(fit.var ~ sample.time - 1, fit.df)$coefficients[["sample.time"]]
            
            tmp <- dff[1, names(dff)[!names(dff) %in% c("sample.time", "num.cells")]]
            tmp$rate <- rate
            tmp$t.end <- factor(t.end)
            return(tmp)
        })
    })
    growth.rates <- do.call(rbind, growth.rates)
    return(growth.rates)
}

#' Approximate values of x and/or y by linearly interpolating data
fitLinear <- function(x, y, pred.x = NULL, pred.y = NULL) {
    #' Do we predict specific values of y?
    if (!is.null(pred.x)) {
        y.vals <- approx(x = x, y = y, xout = pred.x, ties = min)$y
        return(y.vals)
    }
    
    #' Do we predict specific values of x? 
    if (!is.null(pred.y)) {
        x.vals <- approx(x = y, y = x, xout = pred.y, ties = min)$y
        return(x.vals)
    }
    
    #' Do we want a dataframe of x and y predictions?
    if (is.null(pred.x) & is.null(pred.y)) {
        x.vals <- seq(min(x), max(x), length.out = 101)
        y.vals <- approx(x = x, y = y, xout = x.vals, ties = min)$y
        return(data.frame(x = x.vals, y = y.vals) )
    }
}

#' Fit a spline to given x~y data
fitSpline <- function(x, y, weights = NULL, pred.x = NULL, pred.y = NULL, DOF = 8) {
    #' First create a dataframe of x and y, and add weights if necessary
    data <- data.frame(x = x, y = y)
    
    if (is.null(weights)) data$weights <- 1
    else data$weights <- weights
    
    #' Fit the interpolating spline to the data
    mod <- smooth.spline(x = data$x, y = data$y, w = data$weights, df = DOF)
    
    #' Do we predict specific values of y?
    if (!is.null(pred.x)) {
        y.vals <- predict(object = mod, x = pred.x)$y
        return(y.vals)
    }
    
    #' Do we predict specific values of x? 
    if (!is.null(pred.y)) {
        #' First we have to create a list of x and y values using the spline, and thenwe interpolate the x-values for a given y
        x.vals <- seq(min(data$x), max(data$x), length.out = 101)
        y.vals <- predict(object = mod, x = x.vals)$y
        sol <- approx(x = y.vals, y = x.vals, xout = pred.y, ties = min)
        return(sol$y)
    }
    
    #' Do we want a dataframe of x and y predictions?
    if (is.null(pred.x) & is.null(pred.y)) {
        x.vals <- seq(min(data$x), max(data$x), length.out = 101)
        y.vals <- predict(object = mod, x = x.vals)$y
        return(data.frame(x = x.vals, y = y.vals) )
    }
}

#' Fit a spline to given x~y data
fitSigmoid <- function(x, y, weights = NULL, pred.x = NULL, pred.y = NULL) {
    #' First create a dataframe of x and y, and add weights if necessary
    df <- data.frame(x = x, y = y)
    
    if (is.null(weights)) df$weights <- 1
    else df$weights <- weights
    
    #' Sort the dataframe by x
    df <- df[order(df$x), ]
    
    #' First we try to fit a sigmoidal function
    #' Initial inflection guess
    x0.guess <- tryCatch(
        approx(y = df$x, x = df$y, xout = c(0.5), ties = min),
        error = function(e) return(list(y = NA))
    )
    if (!is.finite(x0.guess$y)) x0.guess <- 1
    else x0.guess <- x0.guess$y
    
    #' Initial gradient guess
    a.guess <- max(sapply(c(1:(nrow(df) - 1)), function(i) {
        -4 * (df[i + 1, "y"] - df[i, "y"]) / (df[i + 1, "x"] - df[i, "x"])
    }))
    
    #' Fit sigmoid
    sol <- NULL
    mod <- tryCatch(
        nls(y ~ 1 - 1 / (1 + exp(- a * (x - x0))), data = df, start = list(a = a.guess, x0 = x0.guess),
            weights = df$weights, control = nls.control(minFactor = 2^-16, maxiter = 100)),
        error = function(e) {
            print("failed to fit sigmoid")
            return(NULL)
        }
    )
    
    #' Do we predict specific values of y?
    if (!is.null(pred.x)) {
        y.vals <- predict(object = mod, newdata = data.frame(x = pred.x))
        return(y.vals)
    }
    
    #' Do we predict specific values of x? 
    if (!is.null(pred.y)) {
        #' First we have to create a list of x and y values using the spline, and thenwe interpolate the x-values for a given y
        x.vals <- seq(min(df$x), max(df$x), length.out = 101)
        y.vals <- predict(object = mod, newdata = data.frame(x = x.vals))
        sol <- approx(x = y.vals, y = x.vals, xout = pred.y, ties = min)
        return(sol$y)
    }
    
    #' Do we want a dataframe of x and y predictions?
    if (is.null(pred.x) & is.null(pred.y)) {
        x.vals <- seq(min(df$x), max(df$x), length.out = 101)
        y.vals <- predict(object = mod, newdata = data.frame(x = x.vals))
        return(data.frame(x = x.vals, y = y.vals) )
    }
}

#' From a dataframe containing survival probabilities over a range of drug concentrations, compute the ICx values, such as IC50 and IC90...
#' @param data (dataframe): Dataframe containing the columns survive (survival probability) and drug.outsideConcentration.MULT
#' @value A named vector of ICX values
computeICX <- function(data) {
    #' First we try to fit a sigmoidal function
    #' Initial inflection guess
    x0.guess <- tryCatch(
        approx(y = data$drug.outsideConcentration.MULT, x = data$survive, xout = c(0.5), ties = min),
        error = function(e) return(list(y = NA))
    )
    if (!is.finite(x0.guess$y)) x0.guess <- 1
    else x0.guess <- x0.guess$y
    #' Initial gradient guess
    a.guess <- max(sapply(c(1:(nrow(data) - 1)), function(i) {
        -4 * (data[i + 1, "survive"] - data[i, "survive"]) / (data[i + 1, "drug.outsideConcentration.MULT"] - data[i, "drug.outsideConcentration.MULT"])
    }))
    #' Fit sigmoid (weighted by number of replicates per point)
    sol <- NULL
    mod <- tryCatch(
        nls(survive ~ 1 - 1 / (1 + exp(- a * (drug.outsideConcentration.MULT - x0))), data = data, start = list(a = a.guess, x0 = x0.guess),
            weights = data$num.reps, control = nls.control(minFactor = 2^-16, maxiter = 100)),
        error = function(e) return(NULL)
    )
    
    if (!is.null(mod)) {
        sol <- with(c(coef(mod), list(S = 1 - c(0.5, 0.9, 0.99, 0.999))), x0 - (1/a) * log(S / (1 - S)))
    } else{
        #' Use linear interpolation instead
        sol <- tryCatch(
            approx(y = data$drug.outsideConcentration.MULT, x = data$survive, xout = 1 - c(0.5, 0.9, 0.99, 0.999), ties = min)$y,
            error = function(e) return(NULL)
        )
    }
    if (is.null(sol)) return(NULL)
    
    names(sol) <- c("IC50", "IC90", "IC99", "IC99.9")
    return(sol)
}


